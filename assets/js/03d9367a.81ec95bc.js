"use strict";(self.webpackChunknimbus_docusaurus_template=self.webpackChunknimbus_docusaurus_template||[]).push([[611],{39222:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var i=n(87462),r=(n(67294),n(3905));const o={title:"Nimbus clients",sidebar_position:2,sidebar_label:"Nimbus clients",hide_table_of_contents:!0},a=void 0,s={unversionedId:"clients",id:"clients",title:"Nimbus clients",description:"Nimbus is a suite of Ethereum client implementations designed to be as lightweight, easy to use, and adaptive as possible. The consensus client is the first of three Nimbus implementations to reach production. Meanwhile, an execution client and a true Ethereum light client are still in development.",source:"@site/about/clients.md",sourceDirName:".",slug:"/clients",permalink:"/about/clients",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Nimbus clients",sidebar_position:2,sidebar_label:"Nimbus clients",hide_table_of_contents:!0},sidebar:"defaultSidebar",previous:{title:"Client Diversity and Network Decentralisation For Ethereum",permalink:"/about/"},next:{title:"Development roadmap",permalink:"/about/roadmap"}},l={},u=[{value:"Consensus client",id:"consensus-client",level:2},{value:"Verified web3 proxy",id:"verified-web3-proxy",level:2},{value:"Portal client",id:"portal-client",level:2},{value:"Execution client",id:"execution-client",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Nimbus is a suite of Ethereum client implementations designed to be as lightweight, easy to use, and adaptive as possible. The consensus client is the first of three Nimbus implementations to reach production. Meanwhile, an execution client and a true Ethereum light client are still in development.\nFrom their programming language upwards, Nimbus clients are optimised to conserve system resources, making them suitable to run on embedded systems and lower-specification devices. Nim, the language in which Nimbus clients are written, was chosen for the following reasons:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It is an efficient, general-purpose systems programming language."),(0,r.kt)("li",{parentName:"ul"},"It features Python-like syntax that compiles to C, enabling us to take advantage of the C language's mature tooling for code compilation and static code analysis."),(0,r.kt)("li",{parentName:"ul"},"It has a high degree of reasonability for researchers."),(0,r.kt)("li",{parentName:"ul"},"It is performant in production.\nThe above qualities make it easy for us to bring research into production, resulting in more adaptive, dynamic clients.")),(0,r.kt)("p",null,"Nimbus is fortunate to have multiple Nim contributors working on its client implementations as core team members. Additionally, the wider Nim community has expressed support for the Nimbus project."),(0,r.kt)("h2",{id:"consensus-client"},"Consensus client"),(0,r.kt)("p",null,"The Nimbus consensus client offers significant advantages for all levels of users from hobbyists to institutional operators. The advantages include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Light and high performing: Nimbus consensus client strives to be as lightweight and high performing as possible in terms of resource overhead, leaving more headroom during times of heightened network usage. Operators can also run Nimbus together with other workloads on their servers to reduce overall costs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Flexible: Nimbus consensus client is the only Ethereum client that offers the flexibility of running Beacon Node and validator clients independently, as operators often require. Additionally, it offers a simpler Beacon Node mode in which the Beacon Node assumes validator responsibilities, mitigating the need for operators to manage the two separately.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Convenient: Nimbus will be among the first client teams to offer both a consensus and execution client, simplifying initial installation and making it easy for operators to receive tailored support."))),(0,r.kt)("p",null,"View the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/status-im/nimbus-eth1/tree/master/nimbus"},"Github repository")," or the ",(0,r.kt)("a",{parentName:"p",href:"https://nimbus.guide/quick-start.html"},"setup guide.")),(0,r.kt)("h2",{id:"verified-web3-proxy"},"Verified web3 proxy"),(0,r.kt)("p",null,"Nimbus is working with ethOS on a native and embedded proof of concept to provide additional protections with the verified web3 proxy. The Ethereum JSON-RPC proxy uses the beacon chain light client sync protocol to verify the data supplied by any Ethereum node in order to deliver a new type of ultra light Ethereum client. It enables trust in data from potentially untrustworthy sources by having the proxy perform real-time verification."),(0,r.kt)("p",null,"It simply requires the user to set up a light web3 proxy on their phone and scan the proxy, which fetches the state root from the LC network. This allows the proxy to request the balance and proof from any provider or untrusted node, checking this against the state root and verifying the balance."),(0,r.kt)("p",null,"View the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/status-im/nimbus-eth1/tree/master/nimbus_verified_proxy"},"Github repository.")),(0,r.kt)("h2",{id:"portal-client"},"Portal client"),(0,r.kt)("p",null,"The absence of true light clients presents a major issue in web3 because it contributes to various centralising tendencies on Ethereum. When users cannot validate on-chain data themselves (due to the technical or resource overheads of running their own validating node) they fall back on RPC nodes operated by centralised entities. "),(0,r.kt)("p",null,"While convenient, this approach requires users to trust the data returned and represents a pale imitation of the true revolutionary promise of decentralised blockchain technology."),(0,r.kt)("p",null,"Nimbus portal client, our light client implementation known as \u201cFluffy\u201d, is among a few promising efforts to develop an Ethereum light client. Its development is part of a cross-team Ethereum Foundation initiative called Portal Network that seeks to realise the light client vision. "),(0,r.kt)("p",null,"Alongside the portal client, Nimbus has developed a light, verified web3 proxy that can run in the background of applications, providing on-chain data directly to wallet apps and Ethereum-native operating systems, among other use cases. "),(0,r.kt)("p",null,"Ultimately, light clients will provide greater security to users, reveal new blockchain use cases, and enable the Ethereum ecosystem to reduce its dependency on centralised entities that represent single points of failure or capture."),(0,r.kt)("p",null,"View the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/status-im/nimbus-eth1/tree/master/fluffy"},"Github repository")," or ",(0,r.kt)("a",{parentName:"p",href:"https://fluffy.guide/quick-start.html"},"read more.")),(0,r.kt)("h2",{id:"execution-client"},"Execution client"),(0,r.kt)("p",null,"Following Ethereum's switch to proof-of-stake in 2022, Ethereum validators must operate clients on both the consensus and execution layers. Yet, as of today, no client team offers both an execution and consensus layer client."),(0,r.kt)("p",null,"Although the Nimbus execution client is still in development when in production, pairing the execution layer and consensus layer clients will make for a user-friendly and convenient option for all Ethereum node operator levels in terms of installation and subsequent support."),(0,r.kt)("p",null,"Like the Nimbus consensus client, the execution client is written in Nim and designed to be as lightweight as possible, preserving valuable system resources."),(0,r.kt)("p",null,"View the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/status-im/nimbus-eth1"},"Github repository")))}p.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=u(n),m=r,d=h["".concat(l,".").concat(m)]||h[m]||p[m]||o;return n?i.createElement(d,a(a({ref:t},c),{},{components:n})):i.createElement(d,a({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var u=2;u<o;u++)a[u]=n[u];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);